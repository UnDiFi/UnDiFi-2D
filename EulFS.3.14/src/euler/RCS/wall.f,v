head	1.6;
access
	abonfi
	aldo
	tesistim;
symbols
	release3_14_0:1.6
	release3_13_0:1.6
	release3_12_0:1.6
	release3_11_0:1.6
	release3_10_0:1.6
	release3_8_0:1.6
	release3_7_1:1.6
	release3_7_0:1.6
	release3_4_5:1.6
	release3_4_4:1.6
	release3_4_3:1.6
	release3_4_2:1.6
	release3_4_1:1.5
	release3_4_0:1.5
	release3_3_5:1.5
	release3_3_4:1.4
	release3_3_3:1.4
	release3_3_2:1.3
	release3_3_1:1.3
	release3_3_0:1.2;
locks; strict;
comment	@c @;


1.6
date	2013.08.21.10.49.44;	author abonfi;	state Exp;
branches;
next	1.5;

1.5
date	2013.04.30.07.42.54;	author abonfi;	state Exp;
branches;
next	1.4;

1.4
date	2013.02.06.07.45.21;	author tesistim;	state Exp;
branches;
next	1.3;

1.3
date	2013.01.26.12.21.35;	author abonfi;	state Exp;
branches;
next	1.2;

1.2
date	2012.12.20.10.39.57;	author abonfi;	state Exp;
branches;
next	1.1;

1.1
date	99.12.27.09.31.54;	author aldo;	state Exp;
branches;
next	;


desc
@functions for inviscid wall boundary conditions
@


1.6
log
@Improved Doxygen documentation
@
text
@!> \par Purpose
!>
!> subroutine GETDF2CORRDU computes matrix: 
!> \f[
!> \frac{ \partial F}{\partial U}
!> = \left( \begin{array}{cccc}
!>  0 & n_x & n_y & n_z  \\
!>  0 & u_n + u n_x & u n_y & u n_z  \\
!>  0 & v n_x & u_n + v n_y & v n_z  \\
!>  0 & w n_x & w n_y & u_n + w n_z
!> \end{array} \right)
!> \f]
!> where
!> \f$ F \f$ is given in subroutine INWLLI
!
!> @@param[in] UVW the x,y,z components of the velocity
!> @@param[in] VB the NDIM cartesian component of nodal grid velocity
!> @@param[in] VN the NDIM cartesian component of the inward face normal, scaled by its measure
!> @@param[in] NDIM the dimension of the space
!> @@param[in] NOFVAR nof dofs
!> @@param[out] DFCORRDU the jacobian matrix
!> \author $Author: abonfi $
!> \version $Revision: 1.8 $
!> \date $Date: 2013/08/20 14:48:46 $
!> \warning NOFVAR should be set equal to NDIM+1 in the calling routine
!> \warning This routine has never been tested with a non-zero grid velocity
C     
      SUBROUTINE GETDF2CORRDU(UVW,VB,VN,NDIM,NOFVAR,DFCORRDU)
C
C     $Id: wall.f,v 1.5 2013/04/30 07:42:54 abonfi Exp abonfi $
C
      IMPLICIT NONE
C     .. Parameters ..
      INCLUDE 'constants.h'
C     ..
C     .. Scalar Arguments ..
      INTEGER NDIM,NOFVAR
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION DFCORRDU(NOFVAR,NOFVAR),UVW(NDIM),VN(NDIM),
     &VB(NDIM)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION UDOTN
C     ..
C     We account for the grid velocity
C
      UDOTN = (UVW(1)-VB(1))*VN(1) + (UVW(2)-VB(2))*VN(2)
      IF (NDIM.EQ.3) UDOTN = UDOTN + (UVW(3)-VB(3))*VN(3)

      DFCORRDU(1,1) = ZERO
      DFCORRDU(1,2) = VN(1)
      DFCORRDU(1,3) = VN(2)

      DFCORRDU(2,1) = ZERO
      DFCORRDU(2,2) = UDOTN + UVW(1)*VN(1)
      DFCORRDU(2,3) = UVW(1)*VN(2)

      DFCORRDU(3,1) = ZERO
      DFCORRDU(3,2) = UVW(2)*VN(1)
      DFCORRDU(3,3) = UDOTN + UVW(2)*VN(2)

      IF (NDIM.EQ.3) THEN
          DFCORRDU(1,4) = VN(3)
          DFCORRDU(2,4) = UVW(1)*VN(3)
          DFCORRDU(3,4) = UVW(2)*VN(3)
          DFCORRDU(4,1) = ZERO
          DFCORRDU(4,2) = UVW(3)*VN(1)
          DFCORRDU(4,3) = UVW(3)*VN(2)
          DFCORRDU(4,4) = UDOTN + UVW(3)*VN(3)
      ENDIF

      RETURN

      END
!> \par Purpose
!>
!> subroutine GETDF4CORRDU computes matrix 
!> \f[
!> \frac{\partial F_{n}}{\partial Z} =
!>   \left( \begin{array}{ccccc}
!>  \sqrt{\rho} u_n - 2z_1b_n & 0 & z_1 n_x & z_1 n_y & z_1 n_z  \\
!>  -b_n\,z_2 & \sqrt{\rho}\left(u_n-b_n\right) & z_2 n_x & z_2 n_y & z_2 n_z  \\
!>  -b_n\,z_3 & 0 & \sqrt{\rho}\left(u_n-b_n\right)+ z_3 n_x & z_3 n_y & z_3 n_z  \\
!>  -b_n\,z_4 & 0 & z_4 n_x & \sqrt{\rho}\left(u_n-b_n\right) + z_4 n_y & z_4 n_z  \\
!>  -b_n\,z_5 & 0 & z_5 n_x & z_5 n_y & \sqrt{\rho}\left(u_n-b_n\right) + z_5 n_z
!> \end{array} \right)
!> \f]
!> where:
!> \f[
!> \sqrt{\rho}\left(u_n-b_n\right) =
!> \sqrt{\rho}\left(\mathbf{u}-\mathbf{b}\right)\cdot\mathbf{n} = z_3\,n_x+z_4\,n_y+z_5\,n_z-z_1\,\left(\mathbf{b}\cdot\mathbf{n}\right)
!> \f]
!> and
!> \f$ F \f$ is given in subroutine INWLL
!
!> @@param[in] ZROE Roe's parameter vector in the gridpoint
!> @@param[in] B the NDIM cartesian component of nodal grid velocity
!> @@param[in] VN the NDIM cartesian component of the inward face normal, scaled by its measure
!> @@param[in] NDIM the dimension of the space
!> @@param[in] NOFVAR nof dofs
!> @@param[out] DFCORRDU the jacobian matrix
!
!> \author $Author: abonfi $
!> \version $Revision: 1.8 $
!> \date $Date: 2013/08/20 14:48:46 $
!> \warning NOFVAR should be set equal to NDIM+2 in the calling routine
C     
      SUBROUTINE GETDF4CORRDU(ZROE,B,VN,NDIM,NOFVAR,DFCORRDU)

      IMPLICIT NONE
C     .. Parameters ..
      INCLUDE 'constants.h'

C     .. Scalar Arguments ..
      INTEGER NDIM,NOFVAR
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION B(NDIM),VN(NDIM),ZROE(NOFVAR),
     &DFCORRDU(NOFVAR,NOFVAR)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION UDOTN,BDOTN
C     ..
      UDOTN = ZROE(3)*VN(1) + ZROE(4)*VN(2) ! UDOTN is \sqrt{\rho} (u\,n_x+v\,n_y+w\,n_z)
      BDOTN = B(1)*VN(1) + B(2)*VN(2) ! BDOTN is b_in_i i.e.\ b \cdot \mathbf{n}
      IF (NDIM.EQ.3) THEN
          UDOTN = UDOTN + ZROE(5)*VN(3)
          BDOTN = BDOTN + B(3)*VN(3)
      ENDIF
      UDOTN = UDOTN - BDOTN*ZROE(1) ! now UDOTN is \sqrt{\rho} [(u-b_x)n_x + etc

      DFCORRDU(1,1) = UDOTN-BDOTN*ZROE(1)
      DFCORRDU(1,2) = ZERO
      DFCORRDU(1,3) = VN(1)*ZROE(1)
      DFCORRDU(1,4) = VN(2)*ZROE(1)

      DFCORRDU(2,1) = -BDOTN*ZROE(2)
      DFCORRDU(2,2) = UDOTN
      DFCORRDU(2,3) = ZROE(2)*VN(1)
      DFCORRDU(2,4) = ZROE(2)*VN(2)

      DFCORRDU(3,1) = -BDOTN*ZROE(3)
      DFCORRDU(3,2) = ZERO
      DFCORRDU(3,3) = UDOTN + ZROE(3)*VN(1)
      DFCORRDU(3,4) = ZROE(3)*VN(2)

      DFCORRDU(4,1) = -BDOTN*ZROE(4)
      DFCORRDU(4,2) = ZERO
      DFCORRDU(4,3) = ZROE(4)*VN(1)
      DFCORRDU(4,4) = UDOTN + ZROE(4)*VN(2)

      IF (NDIM.EQ.3) THEN

          DFCORRDU(1,5) = VN(3)*ZROE(1)
          DFCORRDU(2,5) = ZROE(2)*VN(3)
          DFCORRDU(3,5) = ZROE(3)*VN(3)
          DFCORRDU(4,5) = ZROE(4)*VN(3)

          DFCORRDU(5,1) = -BDOTN*ZROE(5)
          DFCORRDU(5,2) = ZERO
          DFCORRDU(5,3) = ZROE(5)*VN(1)
          DFCORRDU(5,4) = ZROE(5)*VN(2)
          DFCORRDU(5,5) = UDOTN + ZROE(5)*VN(3)

      ENDIF

      RETURN

      END
C
!> \details
!> \par Purpose
!>
!>  INVISCID WALL boundary condition (INCompressible flows)
!>
!> add a correction flux having the form:
!> \f[ 
!> F = -\left( \rho \left( \mathbf{u}-\mathbf{b} \right) \cdot \mathbf{n} ,
!> \left( \rho \left( \mathbf{u}-\mathbf{b} \right) \cdot \mathbf{n} \right) \mathbf{u}
!> \right)
!> \f]
!
!> @@param[in] NDIM the dimension of the space
!> @@param[in] VNOR stores the NDIM cartesian component of the inward face normal, scaled by its measure
!> @@param[in] B stores the NDIM cartesian component of nodal grid velocity
!> @@param[in] Z is the vector of primitive variables (p,u,v,w)
!> @@param[out] F the inviscid flux for an inviscid wall (eventually moving)
!> \author $Author: abonfi $
!> \version $Revision: 1.8 $
!> \date $Date: 2013/08/20 14:48:46 $
!
C     
      SUBROUTINE INVWLLI( NDIM , VNOR , B , Z , F )
C
C
      IMPLICIT NONE
C
      INTEGER NDIM
      DOUBLE PRECISION VNOR(NDIM),Z(*),B(NDIM),F(*)
      DOUBLE PRECISION VDOTN
C
C    | U_n         |    | 0   |
C    | U_n U + p n |    | p n |
C
C     We account for the possibility that the grid is moving....
C
      VDOTN      = VNOR(1)*(Z(2)-B(1)) + VNOR(2)*(Z(3)-B(2))
      IF(NDIM.EQ.3)VDOTN = VDOTN + VNOR(3)*(Z(4)-B(3))
C
      F(1) =-VDOTN
      F(2) =-VDOTN * Z(2)
      F(3) =-VDOTN * Z(3)
      IF(NDIM.EQ.3) F(4) =-VDOTN * Z(4)
C
      RETURN
      END
C
!> \details
!> \par Purpose
!>
!> INVISCID WALL boundary condition (Compressible)
!>
!> We add a correction in the form of a boundary flux:
!> \f[ 
!> F = -\left( \rho \left( \mathbf{u}-\mathbf{b} \right) \cdot \mathbf{n} ,
!> \left( \rho \left( \mathbf{u}-\mathbf{b} \right) \cdot \mathbf{n} \right) H,
!> \left( \rho \left( \mathbf{u}-\mathbf{b} \right) \cdot \mathbf{n} \right) \mathbf{u}
!> \right)
!> \f]
!> so that only the pressure flux is (or should be) left afterwords
!>
!> @@param[in] NDIM the dimension of the space
!> @@param[in] VNOR stores the NDIM cartesian component of the inward face normal, scaled by its measure
!> @@param[in] B stores the NDIM cartesian component of nodal grid velocity \f$ \mathbf{b} \f$
!> @@param[in] Z is Roe's parameter vector 
!> @@param[out] F the inviscid flux for an inviscid wall (eventually moving)
!
!> \author $Author: abonfi $
!> \version $Revision: 1.8 $
!> \date $Date: 2013/08/20 14:48:46 $
C     
      SUBROUTINE INVWLL( NDIM , VNOR , B, Z , F )
C
C
      IMPLICIT NONE
C
      INTEGER NDIM
      DOUBLE PRECISION VNOR(NDIM),Z(*),B(NDIM),F(*)
      DOUBLE PRECISION VDOTN
C
C    | rho U_n         |    | 0   |
C    | rho U_n H       |  - | 0   |
C    | rho U_n U + p n |    | p n |
C
C
C     We account for the possibility that the grid is moving....
C
      VDOTN      = VNOR(1)*(Z(3)-Z(1)*B(1)) + VNOR(2)*(Z(4)-Z(1)*B(2))
      IF(NDIM.EQ.3)VDOTN = VDOTN + VNOR(3)*(Z(5)-Z(1)*B(3))
C
      F(1) =-VDOTN * Z(1)
      F(2) =-VDOTN * Z(2)
      F(3) =-VDOTN * Z(3)
      F(4) =-VDOTN * Z(4)
      IF(NDIM.EQ.3)F(5) =-VDOTN * Z(5)
C
      RETURN
      END
C
      SUBROUTINE GETDF4CORRDU4Ar(ZROE,VN,NDIM,NOFVAR,DFCORRDU)

      IMPLICIT NONE
      INCLUDE 'constants.h'
      INCLUDE 'plasma.h' 
      INCLUDE 'dofs.com' 

C     .. Scalar Arguments ..

      INTEGER NDIM,NOFVAR
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION DFCORRDU(NOFVAR,NOFVAR),VN(NDIM),ZROE(NOFVAR)
      INTEGER I,J
!      INTEGER IE,IX,IY,IZ
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION UDOTN
C     ..
C
      UDOTN = ZROE(IX)*VN(1) + ZROE(IY)*VN(2)
      IF (NDIM.EQ.3) UDOTN = UDOTN + ZROE(IZ)*VN(3)
      DO I = 1 , NSP
        DO J = 1 , NSP
            DFCORRDU(I,J) = ZERO
            IF (I.EQ.J) THEN  
                DFCORRDU(I,J) = UDOTN            
            ENDIF
        ENDDO
      ENDDO  

      DO I = 1 , NSP    
        DFCORRDU(I,IE) = ZERO
        DFCORRDU(I,IX) = VN(1)*ZROE(I)
        DFCORRDU(I,IY) = VN(2)*ZROE(I)
      ENDDO

      DO J = 1 , NSP
        DFCORRDU(IE,J) = ZERO
        DFCORRDU(IX,J) = ZERO
        DFCORRDU(IY,J) = ZERO
      ENDDO

      DFCORRDU(IE,IE) = UDOTN
      DFCORRDU(IE,IX) = ZROE(IE)*VN(1)
      DFCORRDU(IE,IY) = ZROE(IE)*VN(2)

      DFCORRDU(IX,IE) = ZERO
      DFCORRDU(IX,IX) = UDOTN + ZROE(IX)*VN(1)
      DFCORRDU(IX,IY) = ZROE(IX)*VN(2)
      
      DFCORRDU(IY,IE) = ZERO
      DFCORRDU(IY,IX) = ZROE(IY)*VN(1)
      DFCORRDU(IY,IY) = UDOTN + ZROE(IY)*VN(2)

      IF (NDIM.EQ.3) THEN
          DO I=1,NSP
            DFCORRDU(I,IZ) = VN(3)*ZROE(I)
            DFCORRDU(IZ,I) = ZERO
          ENDDO
          DFCORRDU(IE,IZ) = ZROE(IE)*VN(3)
          DFCORRDU(IX,IZ) = ZROE(IX)*VN(3)
          DFCORRDU(IY,IZ) = ZROE(IY)*VN(3)
          
          DFCORRDU(IZ,IE) = ZERO
          DFCORRDU(IZ,IX) = ZROE(IZ)*VN(1)
          DFCORRDU(IZ,IY) = ZROE(IZ)*VN(2)
          DFCORRDU(IZ,IZ) = UDOTN + ZROE(IZ)*VN(3)
      ENDIF

      RETURN

      END
      SUBROUTINE INVWLL4Ar( NDIM , VNOR , Z , F )
C
C    .. INVISCID WALL boundary condition ..
C
      IMPLICIT NONE
C
      INCLUDE 'constants.h'
      INCLUDE 'plasma.h' 
      INCLUDE 'dofs.com' 
C
      INTEGER NDIM,ISP
      DOUBLE PRECISION VNOR(*),Z(*),F(*)
      DOUBLE PRECISION VDOTN
C
C
C    | rho U_n         |    | 0   |
C    | rho U_n H       |  - | 0   |
C    | rho U_n U + p n |    | p n |
C
      VDOTN      = VNOR(1)*Z(IX) + VNOR(2)*Z(IY)
      IF(NDIM.EQ.3)VDOTN = VDOTN + VNOR(3)*Z(IZ)
C
      DO ISP = 1 , NSP
        F(ISP) =-VDOTN * Z(ISP)
      ENDDO
      F(IE) =-VDOTN * Z(IE)
      F(IX) =-VDOTN * Z(IX)
      F(IY) =-VDOTN * Z(IY)
      IF(NDIM.EQ.3)F(IZ) =-VDOTN * Z(IZ)
C
      RETURN
      END
C
@


1.5
log
@the integer addresses of the energy and momentum dofs
are now in a common
@
text
@d1 15
a15 1
!> \details
d21 6
a26 1
!> @@param[in] DFCORRDU the jacobian matrix
d30 1
a30 1
C     $Id: wall.f,v 1.4 2013/02/06 07:45:21 tesistim Exp abonfi $
d76 21
a96 1
!> \details
d98 1
a98 1
!> @@param[in] VB the NDIM cartesian component of nodal grid velocity
d102 6
a107 1
!> @@param[in] DFCORRDU the jacobian matrix
d173 11
d189 4
a195 1
C    .. INVISCID WALL boundary condition (INCompressible) ..
d220 13
d235 1
a235 1
!> @@param[in] B stores the NDIM cartesian component of nodal grid velocity
d238 4
a244 1
C    .. INVISCID WALL boundary condition (Compressible) ..
@


1.4
log
@cosmetic changes
@
text
@d11 1
a11 1
C     $Id: wall.f,v 1.3 2013/01/26 12:21:35 abonfi Exp tesistim $
d202 1
d278 1
@


1.3
log
@Added support for an Argon plasma
@
text
@d11 1
a11 1
C     $Id: wall.f,v 1.2 2012/12/20 10:39:57 abonfi Exp abonfi $
d228 1
a228 1
        DFCORRDU(I,IE) = 0.d0
d234 3
a236 3
        DFCORRDU(IE,J) = 0.d0
        DFCORRDU(IX,J) = 0.d0
        DFCORRDU(IY,J) = 0.d0
d243 1
a243 1
      DFCORRDU(IX,IE) = 0.d0
d247 1
a247 1
      DFCORRDU(IY,IE) = 0.d0
d254 1
a254 1
            DFCORRDU(IZ,I) = 0.d0
d260 1
a260 1
          DFCORRDU(IZ,IE) = 0.d0
d269 1
a269 1
      SUBROUTINE INVWLL4Ar( DIM , VNOR , Z , F )
d275 2
d278 1
a278 4
      integer NSP            !eliminare
      parameter (NSP=4)      !eliminare
      INTEGER DIM,ISP
      INTEGER IE,IX,IY,IZ
a281 4
      IE=NSP+1
      IX=NSP+2
      IY=NSP+3
      IZ=NSP+4
d288 1
a288 1
      IF(DIM.EQ.3)VDOTN = VDOTN + VNOR(3)*Z(IZ)
d296 1
a296 1
      IF(DIM.EQ.3)F(IZ) =-VDOTN * Z(IZ)
@


1.2
log
@now supports ALE calculations
@
text
@d11 1
a11 1
C     $Id:$
d193 109
@


1.1
log
@Initial revision
@
text
@d1 11
a12 2
      SUBROUTINE GETDF2CORRDU(UVW,VN,NDIM,NOFVAR,DFCORRDU)

d15 1
a15 2
      DOUBLE PRECISION TWO
      PARAMETER (TWO=2.d0)
d21 2
a22 1
      DOUBLE PRECISION DFCORRDU(NOFVAR,NOFVAR),UVW(NDIM),VN(NDIM)
d27 4
a30 2
      UDOTN = UVW(1)*VN(1) + UVW(2)*VN(2)
      IF (NDIM.EQ.3) UDOTN = UDOTN + UVW(3)*VN(3)
d32 3
a34 3
      DFCORRDU(1,1) = 0.d0
      DFCORRDU(1,2) = VN(1)                *1.d0
      DFCORRDU(1,3) = VN(2)                *1.d0
d36 1
a36 1
      DFCORRDU(2,1) = 0.d0
d40 1
a40 1
      DFCORRDU(3,1) = 0.d0
d45 1
a45 1
          DFCORRDU(1,4) = VN(3)            *1.d0
d48 1
a48 1
          DFCORRDU(4,1) = 0.d0
d57 9
a65 2

      SUBROUTINE GETDF4CORRDU(ZROE,VN,NDIM,NOFVAR,DFCORRDU)
d68 2
d75 2
a76 1
      DOUBLE PRECISION DFCORRDU(NOFVAR,NOFVAR),VN(NDIM),ZROE(NOFVAR)
d79 1
a79 1
      DOUBLE PRECISION UDOTN
d81 7
a87 2
      UDOTN = ZROE(3)*VN(1) + ZROE(4)*VN(2)
      IF (NDIM.EQ.3) UDOTN = UDOTN + ZROE(5)*VN(3)
d89 2
a90 2
      DFCORRDU(1,1) = UDOTN
      DFCORRDU(1,2) = 0.d0
d94 1
a94 1
      DFCORRDU(2,1) = 0.d0
d99 2
a100 2
      DFCORRDU(3,1) = 0.d0
      DFCORRDU(3,2) = 0.d0
d104 2
a105 2
      DFCORRDU(4,1) = 0.d0
      DFCORRDU(4,2) = 0.d0
d116 2
a117 2
          DFCORRDU(5,1) = 0.d0
          DFCORRDU(5,2) = 0.d0
a121 1

a126 1
      SUBROUTINE INVWLLI( DIM , VNOR , Z , F )
d128 10
a137 1
C    .. INVISCID WALL boundary condition ..
d141 2
a142 2
      INTEGER DIM
      DOUBLE PRECISION VNOR(*),Z(*),F(*)
d148 4
a151 2
      VDOTN      = VNOR(1)*Z(2) + VNOR(2)*Z(3)
      IF(DIM.EQ.3)VDOTN = VDOTN + VNOR(3)*Z(4)
d156 1
a156 1
      IF(DIM.EQ.3) F(4) =-VDOTN * Z(4)
d161 8
a168 1
      SUBROUTINE INVWLL( DIM , VNOR , Z , F )
d170 1
a170 1
C    .. INVISCID WALL boundary condition ..
d174 2
a175 2
      INTEGER DIM
      DOUBLE PRECISION VNOR(*),Z(*),F(*)
d182 5
a186 2
      VDOTN      = VNOR(1)*Z(3) + VNOR(2)*Z(4)
      IF(DIM.EQ.3)VDOTN = VDOTN + VNOR(3)*Z(5)
d192 1
a192 1
      IF(DIM.EQ.3)F(5) =-VDOTN * Z(5)
@
